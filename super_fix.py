import os

# CP1250 mapping for bytes 0x80-0xFF
# This is a common corruption source in this project
CP1250_MAP = {
    0x80: 0x20ac, 0x81: None,   0x82: 0x201a, 0x83: None,   0x84: 0x201e, 0x85: 0x2026, 0x86: 0x2020, 0x87: 0x2021,
    0x88: 0x02c6, 0x89: 0x2030, 0x8a: 0x0160, 0x8b: 0x2039, 0x8c: 0x015a, 0x8d: 0x0164, 0x8e: 0x017d, 0x8f: 0x0179,
    0x90: None,   0x91: 0x2018, 0x92: 0x2019, 0x93: 0x201c, 0x94: 0x201d, 0x95: 0x2022, 0x96: 0x2013, 0x97: 0x2014,
    0x98: None,   0x99: 0x2122, 0x9a: 0x0161, 0x9b: 0x203a, 0x9c: 0x015b, 0x9d: 0x0165, 0x9e: 0x017e, 0x9f: 0x017a,
    0xa0: 0x00a0, 0xa1: 0x02c7, 0xa2: 0x02d8, 0xa3: 0x0141, 0xa4: 0x00a4, 0xa5: 0x0104, 0xa6: 0x00a6, 0xa7: 0x00a7,
    0xa8: 0x00a8, 0xa9: 0x00a9, 0xaa: 0x015e, 0xab: 0x00ab, 0xac: 0x00ac, 0xad: 0x00ad, 0xae: 0x00ae, 0xaf: 0x017b,
    0xb0: 0x00b0, 0xb1: 0x00b1, 0xb2: 0x02db, 0xb3: 0x0142, 0xb4: 0x00b4, 0xb5: 0x00b5, 0xb6: 0x00b6, 0xb7: 0x00b7,
    0xb8: 0x00b8, 0xb9: 0x0105, 0xba: 0x015f, 0xbb: 0x00bb, 0xbc: 0x013d, 0xbd: 0x02dd, 0xbe: 0x013e, 0xbf: 0x017c,
    0xc0: 0x0154, 0xc1: 0x00c1, 0xc2: 0x00c2, 0xc3: 0x0102, 0xc4: 0x00c4, 0xc5: 0x0139, 0xc6: 0x0106, 0xc7: 0x00c7,
    0xc8: 0x010c, 0xc9: 0x00c9, 0xca: 0x0118, 0xcb: 0x00cb, 0xcc: 0x011c, 0xcd: 0x00cd, 0xce: 0x00ce, 0xcf: 0x010e,
    0xd0: 0x0110, 0xd1: 0x0143, 0xd2: 0x0147, 0xd3: 0x00d3, 0xd4: 0x00d4, 0xd5: 0x0150, 0xd6: 0x00d6, 0xd7: 0x00d7,
    0xd8: 0x0158, 0xd9: 0x016e, 0xda: 0x00da, 0xdb: 0x0170, 0xdc: 0x00dc, 0xdd: 0x00dd, 0xde: 0x0162, 0xdf: 0x00df,
    0xe0: 0x0155, 0xe1: 0x00e1, 0xe2: 0x00e2, 0xe3: 0x0103, 0xe4: 0x00e4, 0xe5: 0x013a, 0xe6: 0x0107, 0xe7: 0x00e7,
    0xe8: 0x010d, 0xe9: 0x00e9, 0xea: 0x0119, 0xeb: 0x00eb, 0xec: 0x011d, 0xed: 0x00ed, 0xee: 0x00ee, 0xef: 0x010f,
    0xf0: 0x0111, 0xf1: 0x0144, 0xf2: 0x0148, 0xf3: 0x00f3, 0xf4: 0x00f4, 0xf5: 0x0151, 0xf6: 0x00f6, 0xf7: 0x00f7,
    0xf8: 0x0159, 0xf9: 0x016f, 0xfa: 0x00fa, 0xfb: 0x0171, 0xfc: 0x00fc, 0xfd: 0x00fd, 0xfe: 0x0163, 0xff: 0x02d9,
}

# Invert the map: Unicode Char -> CP1250 byte
UNICODE_TO_CP1250 = {v: k for k, v in CP1250_MAP.items() if v is not None}

def try_fix_corrupted_string(s):
    # This string 's' is UTF-8 text where some characters are actually CP1250 bytes of a UTF-8 emoji
    # Example: 'đźš€' -> đ is \u0111, ź is \u017a, š is \u0161, € is \u20ac
    # We convert \u0111 back to \xf0, etc.
    res_bytes = bytearray()
    for char in s:
        code = ord(char)
        if code < 128:
            res_bytes.append(code)
        elif code in UNICODE_TO_CP1250:
            res_bytes.append(UNICODE_TO_CP1250[code])
        else:
            # If we hit an unmappable character, we can't fix this chunk automatically
            return None
    
    try:
        return res_bytes.decode('utf-8')
    except:
        return None

def process_file(file_path):
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # We look for suspicious sequences.
        # Corrupted characters often have codes in the CP1250 mapped range.
        import re
        # This regex looks for sequences of characters that are all > 127 and in our map
        pattern = r'[\u0080-\uffff]{2,}'
        
        def repl(match):
            s = match.group(0)
            fixed = try_fix_corrupted_string(s)
            if fixed:
                return fixed
            return s
            
        new_content = re.sub(pattern, repl, content)
        
        if new_content != content:
            print(f"Fixing {file_path} (super fix)...")
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(new_content)
    except Exception as e:
        print(f"Error: {e}")

def main():
    src_dir = 'src'
    for root, dirs, files in os.walk(src_dir):
        for file in files:
            if file.endswith(('.tsx', '.ts', '.js', '.jsx', '.css', '.md')):
                process_file(os.path.join(root, file))

if __name__ == "__main__":
    main()
